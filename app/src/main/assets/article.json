[
  {"description": "Это элемент программного кода, который описывает то или иное действие в выражении (операцию). В большинстве языков программирования высокого уровня оператор - это символ, благодаря которому могут производиться различные виды вычислений, сравнений или присваиваний с участием одного или нескольких значений.", "sourceId": 32},
  {"description": "Складывает значения по обе стороны от оператора.", "sourceId": 31},
  {"description": "Вычитает правый операнд из левого операнда.", "sourceId": 31},
  {"description": "Умножает значения по обе стороны от оператора.", "sourceId": 31},
  {"description": "Делит левый операнд на правый операнд.", "sourceId": 31},
  {"description": "Делит левый операнд на правый операнд и возвращает остаток.", "sourceId": 31},
  {"description": "Число является положительным по умолчанию.", "sourceId": 31},
  {"description": "Меняет знак числа на противоположный.", "sourceId": 31},
  {"description": "Увеличивает значение операнда на 1.", "sourceId": 31},
  {"description": "Операнд сначала учавствует в выражении, затем наращивается.", "sourceId": 31},
  {"description": "Операнд сначала увеличивается, затем учавствует в выражении.", "sourceId": 31},
  {"description": "Уменьшает значение операнда на 1.", "sourceId": 31},
  {"description": "Операнд сначала учавствует в выражении, затем уменьшается.", "sourceId": 31},
  {"description": "Операнд сначала уменьшается, затем учавствует в выражении.", "sourceId": 31},
  {"description": "Определяет, что два операнда друг другу равны.", "sourceId": 31},
  {"description": "Определяет, что два операнда друг другу не равны.", "sourceId": 31},
  {"description": "Определяет, больше ли один операнд другого.", "sourceId": 31},
  {"description": "Определяет, меньше ли один операнд другого.", "sourceId": 31},
  {"description": "Определяет, что один операнд больше либо равен другому.", "sourceId": 31},
  {"description": "Определяет, что один операнд меньше либо равен другому.", "sourceId": 31},
  {"description": "Меняет значение на противоположное.", "sourceId": 30},
  {"description": "Возвращает истинное значение тогда и только тогда, когда оба операнда истины. Можно применить к целым числам.", "sourceId": 30},
  {"description": "Возвращает истинное значение, когда хотя бы один из операндов истинный. Можно применить к целым числам.", "sourceId": 30},
  {"description": "Возвращает истинное значение, если один и только один из операндов равен истине. Возвращает ложь, если оба операнда равны иситине или ложные. По сути, возвращает истину, если операнды - разные. Можно применить к целым числам.", "sourceId": 30},
  {"description": "Тоже самое, что и &, но если операнд, находящийся слева от & является ложью, данный оператор возвращает ложь без проверки второго операнда.", "sourceId": 30},
  {"description": "Тоже самое, что и |, но если операнд, находящийся слева от | является правдой, данный оператор возвращает правду без проверки второго операнда.", "sourceId": 30},
  {"description": "Простой оператор присваивания, присваивает значения из правой стороны операндов к левому операнду.", "sourceId": 32},
  {"description": "Оператор присваивания «Добавления», он присваивает левому операнду значения правого.", "sourceId": 32},
  {"description": "Оператор присваивания «Вычитания», он вычитает из правого операнда левый операнд.", "sourceId": 32},
  {"description": "Оператор присваивания «Умножение», он умножает правый операнд на левый операнд.", "sourceId": 32},
  {"description": "Оператор присваивания «Деление», он делит левый операнд на правый операнд.", "sourceId": 32},
  {"description": "Оператор присваивания «Модуль», он принимает модуль, с помощью двух операндов и присваивает его результат левому операнду.", "sourceId": 32},
  {"description": "Оператор присваивания побитового «И» («AND»).", "sourceId": 32},
  {"description": "Оператор присваивания побитового «ИЛИ» («OR»).", "sourceId": 32},
  {"description": "Оператор присваивания побитового исключающего «ИЛИ» («XOR»).", "sourceId": 32},
  {"description": "Оператор присваивания «Сдвиг влево».", "sourceId": 32},
  {"description": "Оператор присваивания «Сдвиг вправо».", "sourceId": 32},
  {"description": "Оператор, который состоит из трех операндов и используется для оценки выражений типа boolean. Тернарный оператор в Java также известен как условный оператор. Цель тернарного оператора или условного оператора заключается в том, чтобы решить, какое значение должно быть присвоено переменной.\nпеременная x = (выражение) ? значение if true : значение if false", "sourceId": 32},
  {"description": "Проверяет, является ли объект определенного типа (типа класса или типа интерфейса) и используется только для переменных ссылочного объекта. Оператор instanceof записывается в виде:\n(Переменная ссылочного объекта) instanceof (класс/тип интерфейса)", "sourceId": 32},
  {"description": "-> Постфикс () [] . (точка) \n<- Унарный ++ - - ! ~\n-> Мультипликативный * / %\n-> Аддитивный + -\n->  Сдвиг >> >>> <<\n-> Реляционный > >= < <=\n-> Равенство == !=\n-> Побитовое «И» («AND»)&\n-> Побитовое исключающее «ИЛИ» («XOR»)^\n-> Побитовое «ИЛИ» («OR»)|\n-> Логическое «И» («AND»)&&\n-> Логическое «ИЛИ» («OR»)||\n<- Условный ?: \n<- Присваивание = += -= *= /= %= >>= <<= &= ^= |=\n-> Запятая ,", "sourceId": 32},
  {"description": "Это самый важный элемент практически любого языка программирования. Практически все, что мы пишем в программе - это выражения. Иными словами, любая часть исходного кода, любая комбинация из переменных, констант, функций, которая выполняет какие-то вычисления (действия) - это выражение.", "sourceId": 33},
  {"description": "Когда с оператором используется только один операнд.", "sourceId": 33},
  {"description": "Когда с оператором используется два операнда.", "sourceId": 33},
  {"description": "Это значение, переменная или выражение, которое расположено слева или справа от оператора.", "sourceId": 31},
  {"description": "Это выражение, о котором можно сказать, что оно является истинным или ложным, true или false. Говоря языком Java, логический операнд — это выражение типа boolean или Boolean.", "sourceId": 30},
  {"description": "Если вы действительно хотите быстрее и глубже усваивать новые знания — задумайтесь над тем, как вы задумываетесь. Учитесь учиться.", "sourceId": 2},
  {"description": "Выделите аспекты приложения, которые могут изменяться, и отделите их от тех, которые всегда остаются постоянными.\nИначе говоря, если некий аспект кода изменяется (допустим, с введением новых требований), то его необходимо отделить от тех аспектов, которые остаются неизменными.\nДругая формулировка того же принципа: выделите переменные составляющие и инкапсулируйте их, чтобы позднее их можно было изменять или расширять без воздействия на постоянные составляющие.", "sourceId": 2},
  {"description": "Традиционно в полях объекта могут храниться не только обычные переменные стандартных типов, но и другие объекты. А эти объекты могут в свою очередь хранить какие-то другие объекты и так далее, образуя дерево (иногда граф) объектов. Это отношение называется ассоциацией.", "sourceId": 15},
  {"description": "Жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.", "sourceId": 15},
  {"description": "Жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами.", "sourceId": 15},
  {"description": "«Интерфейс» в данном случае означает «супертип».\nСобственно, главной целью применения полиморфизма посредством программирования на уровне супертипа является как раз отсутствие жесткой привязки к конкретному объекту во время выполнения. Или, другими словами, «переменные должны объявляться с супертипом (обычно абстрактным классом или интерфейсом), чтобы присваиваемые им объекты могли относиться к любой конкретной реализации супертипа».", "sourceId": 2},
  {"description": "Стремитесь к слабой связанности взаимодействующих объектов. Когда два объекта слабо связаны, они могут взаимодействовать друг с другом, но обычно обладают минимумом информации друг о друге", "sourceId": 2},
  {"description": "Шаблон Наблюдатель определяет отношение «один ко многим» между объектами таким образом, что при изменении состояния одного объекта происходит автоматическое оповещение и обновление всех зависимых объектов.\nЕдинственное, что знает субъект о наблюдателе, — то, что тот реализует некоторый интерфейс (Observer).\nЕдинственное, что знает субъект о наблюдателе, — то, что тот реализует некоторый интерфейс (Observer).\nДобавление новых типов наблюдателей не требует модификации субъекта.\nСубъекты и наблюдатели могут повторно использоваться независимо друг от друга.\nИзменения в субъекте или наблюдателе не влияют на другую сторону.", "sourceId": 2},
  {"description": "Шаблон Стратегия определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.", "sourceId": 2}
]




