[
  {"description": "Это самый важный элемент практически любого языка программирования. Практически все, что мы пишем в программе - это выражения. Иными словами, любая часть исходного кода, любая комбинация из переменных, констант, функций, которая выполняет какие-то вычисления (действия) - это выражение.", "sourceId": 17},
  {"description": "Когда с оператором используется только один операнд.", "sourceId": 17},
  {"description": "Когда с оператором используется два операнда.", "sourceId": 17},
  {"description": "Это значение, переменная или выражение, которое расположено слева или справа от оператора.", "sourceId": 15},
  {"description": "Это выражение, о котором можно сказать, что оно является истинным или ложным, true или false. Говоря языком Java, логический операнд — это выражение типа boolean или Boolean.", "sourceId": 14},
  {"description": "Это блок кода, который выполняет специальную задачу.", "sourceId": 0},
  {"description": "Определение части функции (метода) через саму себя, то есть это функция, которая вызывает саму себя, непосредственно (в своём теле) или косвенно (через другую функцию).", "sourceId": 18},
  {"description": "Стек, хранящий информацию для возврата управления из подпрограмм (функций) в программу или подпрограмму (при вложенных или рекурсивных вызовах)", "sourceId": 0},
  {"description": "Структура данных, хранящая набор значений (элементов массива), индентифицируемых по индексу, принимающему целые значения из непрерывного диапазона.", "sourceId": 0},
  {"description": "Атомарность операции чаще всего принято обозначать через ее признак неделимости: операция может либо примениться полностью, либо не примениться вообще. Кроме того, атомарные операции линеаризуемы - грубо говоря, их выполнение можно разложить в одну линейную историю, в то время как просто операции могут производить граф историй, что в ряде случаев неприемлемо.", "sourceId": 0},
  {"description": "Это что-то, что может повлиять на \"чистоту\" вашей функции.", "sourceId": 0},
  {"description": "Способ организации обработки данных, при котором определенные действия повторяются многократно, не приводя при этом к рекурсивным вызовам программ.", "sourceId": 18},
  {"description": "Это элемент программного кода, который описывает то или иное действие в выражении (операцию). В большинстве языков программирования высокого уровня оператор - это символ, благодаря которому могут производиться различные виды вычислений, сравнений или присваиваний с участием одного или нескольких значений.", "sourceId": 16},
  {"description": "Складывает значения по обе стороны от оператора.", "sourceId": 15},
  {"description": "Вычитает правый операнд из левого операнда.", "sourceId": 15},
  {"description": "Умножает значения по обе стороны от оператора.", "sourceId": 15},
  {"description": "Делит левый операнд на правый операнд.", "sourceId": 15},
  {"description": "Делит левый операнд на правый операнд и возвращает остаток.", "sourceId": 15},
  {"description": "Число является положительным по умолчанию.", "sourceId": 15},
  {"description": "Меняет знак числа на противоположный.", "sourceId": 15},
  {"description": "Увеличивает значение операнда на 1.", "sourceId": 15},
  {"description": "Операнд сначала учавствует в выражении, затем наращивается.", "sourceId": 15},
  {"description": "Операнд сначала увеличивается, затем учавствует в выражении.", "sourceId": 15},
  {"description": "Уменьшает значение операнда на 1.", "sourceId": 15},
  {"description": "Операнд сначала учавствует в выражении, затем уменьшается.", "sourceId": 15},
  {"description": "Операнд сначала уменьшается, затем учавствует в выражении.", "sourceId": 15},
  {"description": "Определяет, что два операнда друг другу равны.", "sourceId": 15},
  {"description": "Определяет, что два операнда друг другу не равны.", "sourceId": 15},
  {"description": "Определяет, больше ли один операнд другого.", "sourceId": 15},
  {"description": "Определяет, меньше ли один операнд другого.", "sourceId": 15},
  {"description": "Определяет, что один операнд больше либо равен другому.", "sourceId": 15},
  {"description": "Определяет, что один операнд меньше либо равен другому.", "sourceId": 15},
  {"description": "Меняет значение на противоположное.", "sourceId": 14},
  {"description": "Возвращает истинное значение тогда и только тогда, когда оба операнда истины. Можно применить к целым числам.", "sourceId": 14},
  {"description": "Возвращает истинное значение, когда хотя бы один из операндов истинный. Можно применить к целым числам.", "sourceId": 14},
  {"description": "Возвращает истинное значение, если один и только один из операндов равен истине. Возвращает ложь, если оба операнда равны иситине или ложные. По сути, возвращает истину, если операнды - разные. Можно применить к целым числам.", "sourceId": 14},
  {"description": "Тоже самое, что и &, но если операнд, находящийся слева от & является ложью, данный оператор возвращает ложь без проверки второго операнда.", "sourceId": 14},
  {"description": "Тоже самое, что и |, но если операнд, находящийся слева от | является правдой, данный оператор возвращает правду без проверки второго операнда.", "sourceId": 14},
  {"description": "Простой оператор присваивания, присваивает значения из правой стороны операндов к левому операнду.", "sourceId": 16},
  {"description": "Оператор присваивания «Добавления», он присваивает левому операнду значения правого.", "sourceId": 16},
  {"description": "Оператор присваивания «Вычитания», он вычитает из правого операнда левый операнд.", "sourceId": 16},
  {"description": "Оператор присваивания «Умножение», он умножает правый операнд на левый операнд.", "sourceId": 16},
  {"description": "Оператор присваивания «Деление», он делит левый операнд на правый операнд.", "sourceId": 16},
  {"description": "Оператор присваивания «Модуль», он принимает модуль, с помощью двух операндов и присваивает его результат левому операнду.", "sourceId": 16},
  {"description": "Оператор присваивания побитового «И» («AND»).", "sourceId": 16},
  {"description": "Оператор присваивания побитового «ИЛИ» («OR»).", "sourceId": 16},
  {"description": "Оператор присваивания побитового исключающего «ИЛИ» («XOR»).", "sourceId": 16},
  {"description": "Оператор присваивания «Сдвиг влево».", "sourceId": 16},
  {"description": "Оператор присваивания «Сдвиг вправо».", "sourceId": 16},
  {"description": "Оператор, который состоит из трех операндов и используется для оценки выражений типа boolean. Тернарный оператор в Java также известен как условный оператор. Цель тернарного оператора или условного оператора заключается в том, чтобы решить, какое значение должно быть присвоено переменной.\nпеременная x = (выражение) ? значение if true : значение if false", "sourceId": 16},
  {"description": "Проверяет, является ли объект определенного типа (типа класса или типа интерфейса) и используется только для переменных ссылочного объекта. Оператор instanceof записывается в виде:\n(Переменная ссылочного объекта) instanceof (класс/тип интерфейса)", "sourceId": 16},
  {"description": "-> Постфикс () [] . (точка) \n<- Унарный ++ - - ! ~\n-> Мультипликативный * / %\n-> Аддитивный + -\n-> Сдвиг >> >>> <<\n-> Реляционный > >= < <=\n-> Равенство == !=\n-> Побитовое «И» («AND»)&\n-> Побитовое исключающее «ИЛИ» («XOR»)^\n-> Побитовое «ИЛИ» («OR»)|\n-> Логическое «И» («AND»)&&\n-> Логическое «ИЛИ» («OR»)||\n<- Условный ?: \n<- Присваивание = += -= *= /= %= >>= <<= &= ^= |=\n-> Запятая ,", "sourceId": 16},
  {"description": "Процесс, с которым в текущий момент работает пользователь.\nСчитается активным, если:\n-процесс А выполняет службу, которая используется процессом Б;\n-процесс имеет объект Service и выполняется один из методов обратного вызова, который определен в этом объекте;\n-процесс имеет объект Broadcast Receiver и выполняется его метод обратного вызова для приема намерений.\nУдаляются лишь в случае нехватки памяти.", "sourceId": 0},
  {"description": "Процесс, не имеющий никаких приоритетных компонентов.\nПример:\n-деятельность не на весь экран, не имеет фокуса, но видна пользователю;\n-выполняющий службу, которая связана с деятельность, находящейся на переднем плане, но не активна или частично закрыта другой.", "sourceId": 0},
  {"description": "Процесс, в котором выполняется служба и который не относится к активным и видимым. Не имеет интерфейса, выполняет задания, необходимые пользователю.", "sourceId": 0},
  {"description": "Процесс, в котором выполняется деятельность, которая в текущий момент не видна пользователю. Может быть уничтожена в любой момент.", "sourceId": 0},
  {"description": "Процесс не содержит активных компонентов приложения, используется в качестве кэша системой для более быстрой последующей инициализации компонентов приложения. Удаляются в первую очередь.", "sourceId": 0},
  {"description": "Если вы действительно хотите быстрее и глубже усваивать новые знания — задумайтесь над тем, как вы задумываетесь. Учитесь учиться.", "sourceId": 1},
  {"description": "Выделите аспекты приложения, которые могут изменяться, и отделите их от тех, которые всегда остаются постоянными.\nИначе говоря, если некий аспект кода изменяется (допустим, с введением новых требований), то его необходимо отделить от тех аспектов, которые остаются неизменными.\nДругая формулировка того же принципа: выделите переменные составляющие и инкапсулируйте их, чтобы позднее их можно было изменять или расширять без воздействия на постоянные составляющие.", "sourceId": 1},
  {"description": "Традиционно в полях объекта могут храниться не только обычные переменные стандартных типов, но и другие объекты. А эти объекты могут в свою очередь хранить какие-то другие объекты и так далее, образуя дерево (иногда граф) объектов. Это отношение называется ассоциацией.", "sourceId": 2},
  {"description": "Жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.", "sourceId": 2},
  {"description": "Жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами.", "sourceId": 2},
  {"description": "Шаблон Наблюдатель определяет отношение «один ко многим» между объектами таким образом, что при изменении состояния одного объекта происходит автоматическое оповещение и обновление всех зависимых объектов.\nЕдинственное, что знает субъект о наблюдателе, — то, что тот реализует некоторый интерфейс (Observer).\nЕдинственное, что знает субъект о наблюдателе, — то, что тот реализует некоторый интерфейс (Observer).\nДобавление новых типов наблюдателей не требует модификации субъекта.\nСубъекты и наблюдатели могут повторно использоваться независимо друг от друга.\nИзменения в субъекте или наблюдателе не влияют на другую сторону.", "sourceId": 1},
  {"description": "Шаблон Стратегия определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.", "sourceId": 1}
]




